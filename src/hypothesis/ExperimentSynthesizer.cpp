#include "faultline/hypothesis/ExperimentSynthesizer.h"

#include <llvm/Support/FileSystem.h>
#include <llvm/Support/Path.h>
#include <llvm/Support/raw_ostream.h>

#include <sstream>
#include <system_error>

namespace faultline {

ExperimentFile ExperimentSynthesizer::generateCommonHeader(
    const LatencyHypothesis &hyp) {

    std::ostringstream os;
    os << "#pragma once\n"
       << "// Auto-generated by faultline-experiment-synth\n"
       << "// Hypothesis: " << hyp.hypothesisId << "\n"
       << "// Hazard class: " << hazardClassName(hyp.hazardClass) << "\n"
       << "// Evidence tier: " << evidenceTierName(hyp.evidenceTier) << "\n\n"
       << "#include <cstdint>\n"
       << "#include <atomic>\n"
       << "#include <cstring>\n\n"
       << "// Anti-elision primitives.\n"
       << "// Prevents the compiler from optimizing away the code under test.\n"
       << "static volatile uint64_t faultline_global_sink;\n\n"
       << "template <typename T>\n"
       << "__attribute__((noinline)) void faultline_do_not_optimize("
       << "T const& val) {\n"
       << "    asm volatile(\"\" : : \"r,m\"(val) : \"memory\");\n"
       << "}\n\n"
       << "__attribute__((noinline)) void faultline_clobber_memory() {\n"
       << "    asm volatile(\"\" : : : \"memory\");\n"
       << "}\n\n"
       << "struct LatencySample {\n"
       << "    uint64_t tsc_start;\n"
       << "    uint64_t tsc_end;\n"
       << "};\n\n"
       << "static inline uint64_t faultline_rdtsc() {\n"
       << "    uint64_t lo, hi;\n"
       << "    asm volatile(\"lfence; rdtsc; lfence\"\n"
       << "                 : \"=a\"(lo), \"=d\"(hi));\n"
       << "    return (hi << 32) | lo;\n"
       << "}\n";

    return {"src/common.h", os.str()};
}

ExperimentFile ExperimentSynthesizer::generateHarness(
    const LatencyHypothesis &hyp) {

    std::ostringstream os;
    os << "// Auto-generated harness for hypothesis " << hyp.hypothesisId << "\n"
       << "#include \"common.h\"\n\n"
       << "#include <chrono>\n"
       << "#include <cstdio>\n"
       << "#include <cstdlib>\n"
       << "#include <cstring>\n"
       << "#include <pthread.h>\n"
       << "#include <sched.h>\n"
       << "#include <thread>\n"
       << "#include <vector>\n\n"
       << "// Treatment and control kernels are linked from separate TUs.\n"
       << "extern void treatment_kernel(uint64_t iteration);\n"
       << "extern void control_kernel(uint64_t iteration);\n"
       << "extern void treatment_setup();\n"
       << "extern void control_setup();\n"
       << "extern void treatment_teardown();\n"
       << "extern void control_teardown();\n\n"
       << "static void pin_thread(int core) {\n"
       << "    cpu_set_t cpuset;\n"
       << "    CPU_ZERO(&cpuset);\n"
       << "    CPU_SET(core, &cpuset);\n"
       << "    pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);\n"
       << "}\n\n"
       << "static void run_variant(\n"
       << "    void (*setup)(),\n"
       << "    void (*kernel)(uint64_t),\n"
       << "    void (*teardown)(),\n"
       << "    std::vector<LatencySample> &samples,\n"
       << "    uint64_t warmup,\n"
       << "    uint64_t count) {\n\n"
       << "    setup();\n\n"
       << "    // Warmup phase\n"
       << "    for (uint64_t i = 0; i < warmup; ++i) {\n"
       << "        kernel(i);\n"
       << "        faultline_do_not_optimize(i);\n"
       << "    }\n"
       << "    faultline_clobber_memory();\n\n"
       << "    // Measurement phase\n"
       << "    samples.resize(count);\n"
       << "    for (uint64_t i = 0; i < count; ++i) {\n"
       << "        samples[i].tsc_start = faultline_rdtsc();\n"
       << "        kernel(i);\n"
       << "        samples[i].tsc_end = faultline_rdtsc();\n"
       << "        faultline_do_not_optimize(i);\n"
       << "    }\n\n"
       << "    teardown();\n"
       << "}\n\n"
       << "static void write_samples(const char *path,\n"
       << "                          const std::vector<LatencySample> &samples) {\n"
       << "    FILE *f = fopen(path, \"wb\");\n"
       << "    if (!f) { perror(path); return; }\n"
       << "    fwrite(samples.data(), sizeof(LatencySample), samples.size(), f);\n"
       << "    fclose(f);\n"
       << "}\n\n"
       << "int main(int argc, char **argv) {\n"
       << "    uint64_t warmup = 10000;\n"
       << "    uint64_t count  = 100000;\n"
       << "    int core        = 4;\n"
       << "    const char *variant = \"treatment\";\n\n"
       << "    for (int i = 1; i < argc; ++i) {\n"
       << "        if (strcmp(argv[i], \"--warmup\") == 0 && i+1 < argc)\n"
       << "            warmup = strtoull(argv[++i], nullptr, 10);\n"
       << "        else if (strcmp(argv[i], \"--count\") == 0 && i+1 < argc)\n"
       << "            count = strtoull(argv[++i], nullptr, 10);\n"
       << "        else if (strcmp(argv[i], \"--core\") == 0 && i+1 < argc)\n"
       << "            core = atoi(argv[++i]);\n"
       << "        else if (strcmp(argv[i], \"--variant\") == 0 && i+1 < argc)\n"
       << "            variant = argv[++i];\n"
       << "    }\n\n"
       << "    pin_thread(core);\n\n"
       << "    std::vector<LatencySample> samples;\n\n"
       << "    if (strcmp(variant, \"treatment\") == 0) {\n"
       << "        run_variant(treatment_setup, treatment_kernel,\n"
       << "                    treatment_teardown, samples, warmup, count);\n"
       << "        write_samples(\"results/treatment_samples.bin\", samples);\n"
       << "    } else {\n"
       << "        run_variant(control_setup, control_kernel,\n"
       << "                    control_teardown, samples, warmup, count);\n"
       << "        write_samples(\"results/control_samples.bin\", samples);\n"
       << "    }\n\n"
       << "    return 0;\n"
       << "}\n";

    return {"src/harness.cpp", os.str()};
}

ExperimentFile ExperimentSynthesizer::generateBuildScript(
    const LatencyHypothesis &hyp) {

    std::ostringstream os;
    os << "#!/bin/bash\n"
       << "set -euo pipefail\n\n"
       << "# Auto-generated build script for " << hyp.hypothesisId << "\n"
       << "# Separate compilation units prevent cross-variant optimization.\n\n"
       << "CXX=${CXX:-g++}\n"
       << "FLAGS=\"-O2 -march=native -fno-lto -std=c++20 -pthread\"\n\n"
       << "mkdir -p build results\n\n"
       << "$CXX $FLAGS -c src/treatment.cpp -o build/treatment.o\n"
       << "$CXX $FLAGS -c src/control.cpp -o build/control.o\n"
       << "$CXX $FLAGS src/harness.cpp build/treatment.o "
       << "-o experiment_treatment -Isrc\n"
       << "$CXX $FLAGS src/harness.cpp build/control.o "
       << "-o experiment_control -Isrc\n\n"
       << "echo \"[faultline] Build complete\"\n";

    return {"scripts/build.sh", os.str()};
}

ExperimentFile ExperimentSynthesizer::generateRunAll(
    const MeasurementPlan &plan) {

    std::ostringstream os;
    os << "#!/bin/bash\n"
       << "set -euo pipefail\n\n"
       << "echo \"[faultline] Running full experiment: "
       << plan.hypothesisId << "\"\n\n"
       << "# Environment setup (requires root)\n"
       << "sudo bash scripts/setup_env.sh\n\n"
       << "# Build\n"
       << "bash scripts/build.sh\n\n"
       << "mkdir -p results\n\n"
       << "# Run treatment\n"
       << "./experiment_treatment --variant treatment\n\n"
       << "# Run control\n"
       << "./experiment_control --variant control\n\n"
       << "# PMU collection\n";

    for (const auto &script : plan.scripts) {
        if (script.name == "setup_env.sh" || script.name == "teardown_env.sh")
            continue;
        os << "bash scripts/" << script.name << " treatment\n";
        os << "bash scripts/" << script.name << " control\n\n";
    }

    os << "# Environment teardown\n"
       << "sudo bash scripts/teardown_env.sh\n\n"
       << "echo \"[faultline] Experiment complete. Results in results/\"\n";

    return {"scripts/run_all.sh", os.str()};
}

ExperimentFile ExperimentSynthesizer::generateMakefile() {
    std::ostringstream os;
    os << "CXX ?= g++\n"
       << "CXXFLAGS = -O2 -march=native -fno-lto -std=c++20 -pthread\n\n"
       << "all: experiment_treatment experiment_control\n\n"
       << "build/treatment.o: src/treatment.cpp src/common.h\n"
       << "\t@mkdir -p build\n"
       << "\t$(CXX) $(CXXFLAGS) -c $< -o $@ -Isrc\n\n"
       << "build/control.o: src/control.cpp src/common.h\n"
       << "\t@mkdir -p build\n"
       << "\t$(CXX) $(CXXFLAGS) -c $< -o $@ -Isrc\n\n"
       << "experiment_treatment: src/harness.cpp build/treatment.o\n"
       << "\t$(CXX) $(CXXFLAGS) $^ -o $@ -Isrc\n\n"
       << "experiment_control: src/harness.cpp build/control.o\n"
       << "\t$(CXX) $(CXXFLAGS) $^ -o $@ -Isrc\n\n"
       << "clean:\n"
       << "\trm -rf build experiment_treatment experiment_control results\n\n"
       << ".PHONY: all clean\n";

    return {"Makefile", os.str()};
}

ExperimentFile ExperimentSynthesizer::generateReadme(
    const LatencyHypothesis &hyp) {

    std::ostringstream os;
    os << "# Experiment: " << hyp.hypothesisId << "\n\n"
       << "## Hazard Class\n\n"
       << hazardClassName(hyp.hazardClass) << "\n\n"
       << "## Hypothesis\n\n"
       << "**H0:** " << hyp.H0 << "\n\n"
       << "**H1:** " << hyp.H1 << "\n\n"
       << "## Primary Metric\n\n"
       << hyp.primaryMetric.name << " (" << hyp.primaryMetric.unit << ")\n\n"
       << "## Statistical Parameters\n\n"
       << "- Minimum detectable effect: "
       << (hyp.minimumDetectableEffect * 100) << "%\n"
       << "- Significance level (α): " << hyp.significanceLevel << "\n"
       << "- Power (1-β): " << hyp.power << "\n"
       << "- Evidence tier: " << evidenceTierName(hyp.evidenceTier) << "\n\n"
       << "## Running\n\n"
       << "```bash\n"
       << "bash scripts/run_all.sh\n"
       << "```\n\n"
       << "Requires root for environment configuration.\n\n"
       << "## Limitations\n\n"
       << "Synthetic experiments cannot reproduce:\n"
       << "- Production traffic shape and microburst arrival patterns\n"
       << "- Full system interaction (NIC → kernel → userspace → response)\n"
       << "- Allocator fragmentation history\n"
       << "- OS scheduler interference beyond isolated cores\n"
       << "- Thermal throttling under sustained load\n\n"
       << "See BOUNDARIES.md for full epistemic limits.\n";

    return {"README.md", os.str()};
}

ExperimentFile ExperimentSynthesizer::generateHypothesisJson(
    const LatencyHypothesis &hyp) {

    std::ostringstream os;
    os << "{\n"
       << "  \"hypothesis_id\": \"" << hyp.hypothesisId << "\",\n"
       << "  \"finding_id\": \"" << hyp.findingId << "\",\n"
       << "  \"hazard_class\": \"" << hazardClassName(hyp.hazardClass) << "\",\n"
       << "  \"H0\": \"" << hyp.H0 << "\",\n"
       << "  \"H1\": \"" << hyp.H1 << "\",\n"
       << "  \"primary_metric\": {\n"
       << "    \"name\": \"" << hyp.primaryMetric.name << "\",\n"
       << "    \"unit\": \"" << hyp.primaryMetric.unit << "\",\n"
       << "    \"percentile\": \"" << hyp.primaryMetric.percentile << "\"\n"
       << "  },\n"
       << "  \"minimum_detectable_effect\": " << hyp.minimumDetectableEffect << ",\n"
       << "  \"significance_level\": " << hyp.significanceLevel << ",\n"
       << "  \"power\": " << hyp.power << ",\n"
       << "  \"evidence_tier\": \"" << evidenceTierName(hyp.evidenceTier) << "\",\n"
       << "  \"verdict\": \"" << verdictName(hyp.verdict) << "\"\n"
       << "}\n";

    return {"hypothesis.json", os.str()};
}

ExperimentBundle ExperimentSynthesizer::synthesize(
    const LatencyHypothesis &hypothesis,
    const MeasurementPlan &plan,
    const std::string &outputDir) {

    ExperimentBundle bundle;
    bundle.findingId = hypothesis.findingId;
    bundle.hypothesisId = hypothesis.hypothesisId;
    bundle.outputDir = outputDir;
    bundle.measurementPlan = plan;

    bundle.files.push_back(generateCommonHeader(hypothesis));
    bundle.files.push_back(generateHarness(hypothesis));
    bundle.files.push_back(generateBuildScript(hypothesis));
    bundle.files.push_back(generateMakefile());
    bundle.files.push_back(generateReadme(hypothesis));
    bundle.files.push_back(generateHypothesisJson(hypothesis));
    bundle.files.push_back(generateRunAll(plan));

    for (const auto &script : plan.scripts) {
        bundle.files.push_back({"scripts/" + script.name, script.content});
    }

    return bundle;
}

bool ExperimentSynthesizer::writeToDisk(const ExperimentBundle &bundle) {
    for (const auto &file : bundle.files) {
        llvm::SmallString<256> fullPath(bundle.outputDir);
        llvm::sys::path::append(fullPath, file.relativePath);

        llvm::SmallString<256> parentDir = fullPath;
        llvm::sys::path::remove_filename(parentDir);
        if (auto ec = llvm::sys::fs::create_directories(parentDir))
            return false;

        std::error_code EC;
        llvm::raw_fd_ostream out(fullPath, EC, llvm::sys::fs::OF_Text);
        if (EC)
            return false;
        out << file.content;
    }
    return true;
}

} // namespace faultline
